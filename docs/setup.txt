How I Approach the Data Access Layer (Code-First)

I’ve been using the code-first approach for building the data access layer, where the database schema evolves directly from the code.

The general flow stays the same:
entity classes are created first, the DbContext is defined, schemas are configured, migrations are generated, and the database is updated based on those changes. The database ends up being a reflection of the code rather than the other way around.

What I Learned Along the Way

Initially, I used a mix of data annotations and Fluent API. Data annotations worked fine for basic rules like required fields or max lengths. But as soon as things got slightly more complex—delete behaviors, composite keys, or advanced relationships—I had to fall back to the Fluent API anyway.

Over time, I realized that this mix caused the schema definition to be split across multiple places. Some rules lived in the entity, others in the DbContext. Reading or modifying the table design meant jumping back and forth, which didn’t feel great from a maintainability perspective.

That’s when I decided to rely entirely on the Fluent API.

How I Structure It Now

Instead of placing all configuration logic inside ApplicationDbContext, I use separate configuration classes for each entity.
For example, a User entity has a corresponding UserConfiguration class, and all database-related rules for that entity live there.

To keep things simple and avoid manually wiring up each configuration, I use:

modelBuilder.ApplyConfigurationsFromAssembly(typeof(ApplicationDbContext).Assembly);


This automatically applies all configuration classes in the assembly.

The Outcome

What I noticed after adopting this approach:

Entity classes remain clean and focused on domain logic

Database configuration is explicit and centralized

The data access layer feels easier to reason about as it grows

Overall, it led to a cleaner mental model for both the code and the database schema.